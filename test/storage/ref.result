-- test-run result file version 2
test_run = require('test_run').new()
 | ---
 | ...
netbox = require('net.box')
 | ---
 | ...
REPLICASET_1 = { 'storage_1_a', 'storage_1_b' }
 | ---
 | ...
REPLICASET_2 = { 'storage_2_a', 'storage_2_b' }
 | ---
 | ...

test_run:create_cluster(REPLICASET_1, 'storage')
 | ---
 | ...
test_run:create_cluster(REPLICASET_2, 'storage')
 | ---
 | ...
util = require('util')
 | ---
 | ...
util.wait_master(test_run, REPLICASET_1, 'storage_1_a')
 | ---
 | ...
util.wait_master(test_run, REPLICASET_2, 'storage_2_a')
 | ---
 | ...
util.map_evals(test_run, {REPLICASET_1, REPLICASET_2}, 'bootstrap_storage()')
 | ---
 | ...

_ = test_run:switch('storage_1_a')
 | ---
 | ...
vshard.storage.rebalancer_disable()
 | ---
 | ...
vshard.storage.bucket_force_create(1, 1500)
 | ---
 | - true
 | ...

_ = test_run:switch('storage_2_a')
 | ---
 | ...
vshard.storage.rebalancer_disable()
 | ---
 | ...
vshard.storage.bucket_force_create(1501, 1500)
 | ---
 | - true
 | ...

_ = test_run:switch('storage_1_a')
 | ---
 | ...
lref = require('vshard.storage.ref')
 | ---
 | ...
--
-- Simple ref-unref sequence.
--
rid = 0
 | ---
 | ...
sid = 0
 | ---
 | ...
timeout = 1000
 | ---
 | ...
lref.add(rid, sid, timeout)
 | ---
 | - true
 | ...
lref.count
 | ---
 | - 1
 | ...
lref.use(rid, sid)
 | ---
 | - true
 | ...
lref.count
 | ---
 | - 1
 | ...
lref.del(rid, sid)
 | ---
 | - true
 | ...
lref.count
 | ---
 | - 0
 | ...

-- Bad ref ID.
rid = 1
 | ---
 | ...
_, err = lref.use(rid, sid)
 | ---
 | ...
err.name
 | ---
 | - STORAGE_REF_USE
 | ...
_, err = lref.del(rid, sid)
 | ---
 | ...
err.name
 | ---
 | - STORAGE_REF_DEL
 | ...
-- Bad session ID.
rid = 0
 | ---
 | ...
sid = 1
 | ---
 | ...
_, err = lref.use(rid, sid)
 | ---
 | ...
err.name
 | ---
 | - STORAGE_REF_USE
 | ...
_, err = lref.del(rid, sid)
 | ---
 | ...
err.name
 | ---
 | - STORAGE_REF_DEL
 | ...

-- Duplicate ID.
lref.add(rid, sid, timeout)
 | ---
 | - true
 | ...
_, err = lref.add(rid, sid, timeout)
 | ---
 | ...
err.name
 | ---
 | - STORAGE_REF_ADD
 | ...
lref.count
 | ---
 | - 1
 | ...
lref.use(rid, sid)
 | ---
 | - true
 | ...
lref.del(rid, sid)
 | ---
 | - true
 | ...
lref.count
 | ---
 | - 0
 | ...

-- Ref addition expires 2 old refs.
sid = 0
 | ---
 | ...
timeout = 0.000001
 | ---
 | ...
do                                                                              \
    lref.add(0, sid, timeout)                                                   \
    lref.add(1, sid, timeout)                                                   \
    lref.add(2, sid, timeout)                                                   \
end
 | ---
 | ...
fiber.sleep(timeout)
 | ---
 | ...
lref.count
 | ---
 | - 3
 | ...
lref.add(3, sid, 0)
 | ---
 | - true
 | ...
lref.count
 | ---
 | - 2
 | ...
lref.add(4, sid, 0)
 | ---
 | - true
 | ...
lref.count
 | ---
 | - 1
 | ...

-- Ensure that if a ref is used, it updates the session heap properly.
big_timeout = 1000000
 | ---
 | ...
sid2 = 1
 | ---
 | ...
do                                                                              \
    lref.add(0, sid, big_timeout)                                               \
    lref.add(1, sid, timeout)                                                   \
    lref.use(0, sid)                                                            \
    lref.del(0, sid)                                                            \
    lref.gc()                                                                   \
    return lref.count                                                           \
end
 | ---
 | - 1
 | ...
-- Now the other ref should be collected by GC, because its session should have
-- been moved on top.
fiber.sleep(timeout)
 | ---
 | ...
lref.gc()
 | ---
 | ...
lref.count
 | ---
 | - 0
 | ...

--
-- Bucket moves are not allowed under a ref.
--
util = require('util')
 | ---
 | ...
rid = 0
 | ---
 | ...
norm_timeout = 0.01
 | ---
 | ...
lref.add(rid, sid, big_timeout)
 | ---
 | - true
 | ...
-- Send fails.
vshard.storage.bucket_send(1, util.replicasets[2], {timeout = norm_timeout})
 | ---
 | - null
 | - errno: 60
 |   base_type: TimedOut
 |   type: TimedOut
 |   message: timed out
 |   trace:
 |   - file: /Users/gerold/Work/Repositories/tarantool/src/lib/core/fiber_cond.c
 |     line: 108
 | ...
lref.use(rid, sid)
 | ---
 | - true
 | ...
-- Still fails - use only makes ref undead until it is deleted explicitly.
vshard.storage.bucket_send(1, util.replicasets[2], {timeout = norm_timeout})
 | ---
 | - null
 | - errno: 60
 |   base_type: TimedOut
 |   type: TimedOut
 |   message: timed out
 |   trace:
 |   - file: /Users/gerold/Work/Repositories/tarantool/src/lib/core/fiber_cond.c
 |     line: 108
 | ...

_ = test_run:switch('storage_2_a')
 | ---
 | ...
-- Receive (from another replicaset) also fails.
norm_timeout = 0.01
 | ---
 | ...
vshard.storage.bucket_send(1501, util.replicasets[1], {timeout = norm_timeout})
 | ---
 | - null
 | - code: 78
 |   base_type: ClientError
 |   type: ClientError
 |   message: Timeout exceeded
 |   trace:
 |   - file: builtin/box/net_box.lua
 |     line: 421
 | ...

--
-- After unref all the bucket moves are allowed again.
--
_ = test_run:switch('storage_1_a')
 | ---
 | ...
lref.del(rid, sid)
 | ---
 | - true
 | ...

vshard.storage.bucket_send(1, util.replicasets[2], {timeout = big_timeout})
 | ---
 | - true
 | ...
wait_bucket_is_collected(1)
 | ---
 | ...

_ = test_run:switch('storage_2_a')
 | ---
 | ...
big_timeout = 1000000
 | ---
 | ...
vshard.storage.bucket_send(1, util.replicasets[1], {timeout = big_timeout})
 | ---
 | - true
 | ...
wait_bucket_is_collected(1)
 | ---
 | ...

--
-- While bucket move is in progress, ref won't work.
--
vshard.storage.internal.errinj.ERRINJ_LAST_RECEIVE_DELAY = true
 | ---
 | ...

_ = test_run:switch('storage_1_a')
 | ---
 | ...
fiber = require('fiber')
 | ---
 | ...
_ = fiber.create(vshard.storage.bucket_send, 1, util.replicasets[2],            \
                 {timeout = big_timeout})
 | ---
 | ...
ok, err = lref.add(rid, sid, timeout)
 | ---
 | ...
err.type
 | ---
 | - TimedOut
 | ...
-- Ref will wait if timeout is big enough.
ok, err = nil, nil
 | ---
 | ...
_ = fiber.create(function()                                                     \
    ok, err = lref.add(rid, sid, big_timeout)                                   \
end)
 | ---
 | ...

_ = test_run:switch('storage_2_a')
 | ---
 | ...
vshard.storage.internal.errinj.ERRINJ_LAST_RECEIVE_DELAY = false
 | ---
 | ...

_ = test_run:switch('storage_1_a')
 | ---
 | ...
wait_bucket_is_collected(1)
 | ---
 | ...
test_run:wait_cond(function() return ok or err end)
 | ---
 | - true
 | ...
lref.use(rid, sid)
 | ---
 | - true
 | ...
lref.del(rid, sid)
 | ---
 | - true
 | ...
ok, err
 | ---
 | - true
 | - null
 | ...

_ = test_run:switch('storage_2_a')
 | ---
 | ...
vshard.storage.bucket_send(1, util.replicasets[1], {timeout = big_timeout})
 | ---
 | - true
 | ...
wait_bucket_is_collected(1)
 | ---
 | ...

-- --
-- -- Bucket move tries to collect expired refs before give up.
-- --
-- _ = test_run:switch('storage_1_a')
-- do                                                                              \
--     ref = vshard.storage.internal.storage_ref_add(rid, sid, timeout)            \
--     ok, err = vshard.storage.bucket_send(1, util.replicasets[2],                \
--                                          {timeout = big_timeout})               \
-- end
-- ok, err
-- fiber.sleep(timeout)
-- vshard.storage.bucket_send(1, util.replicasets[2], {timeout = big_timeout})
-- -- Fails - the ref has expired.
-- vshard.storage.internal.storage_ref_use(rid, sid)
-- wait_bucket_is_collected(1)

_ = test_run:switch("default")
 | ---
 | ...
test_run:drop_cluster(REPLICASET_2)
 | ---
 | ...
test_run:drop_cluster(REPLICASET_1)
 | ---
 | ...
